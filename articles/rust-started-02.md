---
title: "Rustå…¥é–€2" # è¨˜äº‹ã®ã‚¿ã‚¤ãƒˆãƒ«
emoji: "ğŸ‘¶" # ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹çµµæ–‡å­—ï¼ˆ1æ–‡å­—ã ã‘ï¼‰
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢è¨˜äº‹
topics: ["rust"] # ã‚¿ã‚°ã€‚["markdown", "rust", "aws"]ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹
published: true # å…¬é–‹è¨­å®šï¼ˆfalseã«ã™ã‚‹ã¨ä¸‹æ›¸ãï¼‰
---

# åŸºæœ¬

## ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹

### ãƒ¦ãƒ‹ãƒƒãƒˆå‹
ç©ºã‚’è¡¨ã™å‹ã§ã‚µã‚¤ã‚ºã‚‚0ãƒã‚¤ãƒˆã«ãªã‚‹ã€‚  
ç©ºã®ã‚¿ãƒ—ãƒ«å‹ã§ `()` ã§è¡¨ç¾ã™ã‚‹ã€‚  
å€¤ã‚’è¿”ã•ãªã„é–¢æ•°ã®æˆ»ã‚Šå€¤ã‚‚ãƒ¦ãƒ‹ãƒƒãƒˆå‹ã«ãªã‚‹ã€‚  

### çœŸç†å€¤
boolå‹  
å€¤ã¯ `true`, `false` ã‚’æŒã¤ã€‚

### æ•´æ•°
| å‹     | ç¬¦å·  | ãƒ“ãƒƒãƒˆå¹…      |
| ----- | --- | --------- |
| i8    | ã‚ã‚Š  | 8         |
| u8    | ãªã—  | 8         |
| i16   | ã‚ã‚Š  | 16        |
| u16   | ãªã—  | 16        |
| i32   | ã‚ã‚Š  | 32        |
| u32   | ãªã—  | 32        |
| i64   | ã‚ã‚Š  | 64        |
| u64   | ãªã—  | 64        |
| i128  | ã‚ã‚Š  | 128       |
| u128  | ãªã—  | 128       |
| isize | ã‚ã‚Š  | ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒ“ãƒƒãƒˆå¹… |
| usize | ãªã—  | ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒ“ãƒƒãƒˆå¹… |

usizeå‹ã¯é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚„é•·ã•ãªã©ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã€‚  

#### æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«
æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§i32ã«ãªã‚‹ã€‚  
å‹ã‚’æŒ‡å®šã™ã‚‹å ´åˆ `0u8` ã“ã®ã‚ˆã†ã«ã‚µãƒ•ã‚£ãƒƒã‚¯ã‚¹ã«å‹ã‚’æ›¸ã„ã¦æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚  
æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã«ã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’åˆ©ç”¨ã—ã¦èª­ã¿ã‚„ã™ã„å½¢ã§æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚  

```
let n1 = 10_000; // i32å‹
let n2 = 0u8; // u8å‹
let n3 = -100_isize; // isizeå‹


let n4 = 10;      
let n5 = n3 + n4; // ã“ã“ã§ isizeå‹ + n4 ã®è¨ˆç®—ã‚’ã—ã¦ã„ã‚‹ã®ã§å‹æ¨è«–ã§n4ã‚‚isizeå‹ã«ãªã‚‹
```

#### 10é€²æ•°ä»¥å¤–ã®æ•°å€¤
```
let n1 = 0xff; // 16é€²æ•°
let n2 = 0o744; // 8é€²æ•°
let n3 = 0b1010; // 2é€²æ•°
```

#### ã‚¢ã‚¹ã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰
```
let n1 = b`A`; // ASCIIæ–‡å­—'A'ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰65u8ã«ãªã‚‹
```

### å°‘æ•°
f32å‹ã¨f64å‹ãŒã‚ã‚‹ã€‚  
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯f64å‹ã«ãªã‚‹ã€‚  
æ•´æ•°å‹ã¨åŒæ§˜ã«ã‚µãƒ•ã‚£ãƒƒã‚¯ã‚¹ã«å‹ã‚’æ›¸ã„ã¦æŒ‡å®šãŒã§ãã‚‹ã€‚  
```
let f1 = 10.0; // f64
let f2 = 1_234.567f32; // f32
let f3 = 578.6E+77; // f64 æŒ‡æ•°æŒ‡å®š
```

### æ–‡å­—
Unicodeã®1æ–‡å­—ã‚’æŒã¤ã€‚  
charãƒªãƒ†ãƒ©ãƒ«ã¯ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§ä½œã‚‹ã€‚  
1æ–‡å­—ã‚’è¡¨ã™ã®ã«è‹±æ•°ã§ã‚‚4ãƒã‚¤ãƒˆã‚’ä½¿ã†ã€‚  

```
let c1 = 'A'; // charå‹
let c2 = 'a';

assert!(c1.is_uppercase()); // å¤§æ–‡å­—ã‹æ¤œè¨¼
let c3 = '0';
assert!(c3.is_digit(10)); // 10é€²æ•°æ•°å­—ã‹æ¤œè¨¼

let c9 = 'æ¼¢'; // ãƒãƒ«ãƒãƒã‚¤ãƒˆæ–‡å­—ã‚‚å¯èƒ½
```

### å‚ç…§
ãƒ¡ãƒ¢ãƒªå®‰å…¨ãªãƒã‚¤ãƒ³ã‚¿  
`&T`, `&mut T` ã§å®šç¾©ã™ã‚‹ã€‚

- &T  
ä¸å¤‰å‚ç…§ã€€readonly
- &mut T
å¯å¤‰å‚ç…§ read&writeå¯èƒ½

```
let c1 = 'A';
let c1_ptr = &c1;       // ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«å‚ç…§

let mut n1 = 0;
let n1_ptr = &mut n1;  // ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«å‚ç…§
*n1_ptr = 100; // å‚ç…§å¤–ã—ã‚’ã—ã¦å€¤ã®å¤‰æ›´
```

### ç”Ÿãƒã‚¤ãƒ³ã‚¿
ãƒ¡ãƒ¢ãƒªå®‰å…¨ã§ã¯ãªã„ãƒã‚¤ãƒ³ã‚¿  
`*const T`, `*mut T` ã§å®šç¾©ã™ã‚‹ã€‚  

- *const T  
ä¸å¤‰å‚ç…§ã€€readonly
- *mut T
å¯å¤‰å‚ç…§ read&writeå¯èƒ½

ç”Ÿãƒã‚¤ãƒ³ã‚¿ã¯ä»–ã®è¨€èªã¨ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å—ã‘æ¸¡ã—ã«ã‚ˆã‚‹é€£æºã‚„æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å¤–ã—ãŸã„å ´åˆã«åˆ©ç”¨ã™ã‚‹ã€‚  
å‚ç…§å¤–ã—ã€ä»–ã®ãƒã‚¤ãƒ³ã‚¿ã¸ã®å‹å¤‰æ›ã¯ `unsafe` ãƒ–ãƒ­ãƒƒã‚¯ã«æ›¸ãå¿…è¦ãŒã‚ã‚‹ã€‚

```
let c1 = 100;
let c1_ptr: *const char = &c1;
unsafe{
    println!(*c1_ptr);
}

let mut n1 = 0;
let n1_ptr: *mut i32 = &mut n1;
unsafe{
    println!(*n1_ptr);
}
```

### é–¢æ•°ãƒã‚¤ãƒ³ã‚¿
é–¢æ•°ã‚’ç¤ºã™ãƒã‚¤ãƒ³ã‚¿ã€€ã‚µã‚¤ã‚ºã¯usizeã¨åŒã˜ã«ãªã‚‹ã€‚
`fn(T) -> T` ã§å®šç¾©ã™ã‚‹ã€‚  
é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ã®å ´åˆå‹æ³¨é‡ˆã¯æ›¸ãå¿…è¦ãŒã‚ã‚‹ã€‚  
æ›¸ã‹ãªã„å ´åˆé–¢æ•°å®šç¾©å‹ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã€‚ ã‚µã‚¤ã‚ºã¯0ãƒã‚¤ãƒˆ
é–¢æ•°ã”ã¨ã«ç•°ãªã‚‹å‹ã«ãªã‚‹ã€‚  
é–¢æ•°å®šç¾©å‹ã¯åŒ¿åå‹ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã®å‹åã¨ã—ã¦åˆ©ç”¨ã¯ã§ããªã„ã€‚  

```
fn type_of<T>(_: T) -> String {
    let a = std::any::type_name::<T>();
    return a.to_string();
}

fn double(value: i32) -> i32 {
    value * 2
}

let f1: fn(i32) -> i32 = double;
println!("function pointer: {}", f1(5));

let f2 = double;
println!("function pointer: {}", type_of(f1)); // function pointer: fn(i32) -> i32
println!("function pointer: {}", type_of(f2)); // function pointer: firststep::double
```

### ã‚¿ãƒ—ãƒ«
è¤‡æ•°ã®å‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
`(å€¤, å€¤)` ã§å®šç¾©ã™ã‚‹ã€‚  

#### å„è¦ç´ ã®ã‚¢ã‚¯ã‚»ã‚¹
**ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å**
`å¤‰æ•°å.å®šæ•°`ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
å®šæ•°ã¯ãƒ‡ãƒ¼ã‚¿ã®å…ˆé ­ã‚’0ã‹ã‚‰å§‹ã¾ã‚‹  

```
let t1 = (1, true);
let n = t1.0;

let mut t2 = (1, true);
t2.0 = 2;
```

**ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ**
`let (x1, x2) = tupleå¤‰æ•°` ã¨ã™ã‚‹ã“ã¨ã§ã€xã«ã‚¿ãƒ—ãƒ«ã®å†…å®¹ã‚’æŸç¸›ã—ã¦ãã‚Œã‚‹ã€‚  
è¦ç´ ã‚’æ›¸ãæ›ãˆã‚‹å ´åˆ `ref mut` ã‚’å¤‰æ•°åã®å‰ã«ä»˜ã‘ã‚‹ã€‚  

```
let t1 = (1, true);
let (n1, b1) = t1;

let t2 = (1, true);
let (n2, _) = t2; // ä¸è¦ãªå€¤ã«ã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’ä½¿ã†ã¨ç„¡è¦–ã§ãã‚‹ã€‚

// è¦ç´ ã‚’æ›¸ãæ›ãˆã‚‹å ´åˆ
let mut t3 = (2, false);
let (ref mut n3, ref mut b3) = t3;
```

### é…åˆ—
ãƒ¡ãƒ¢ãƒªä¸Šã«é€£ç¶šã—ãŸé ˜åŸŸã‚’ç¢ºä¿ã™ã‚‹ã€‚  
`[å€¤, å€¤]` ã§å®šç¾©ã™ã‚‹ã€‚  
å‹æŒ‡å®šã‚’ã™ã‚‹å ´åˆ `let x: [å‹;è¦ç´ æ•°]` ã¨æ›¸ãã€‚  
ã‚µã‚¤ã‚ºã‚’èª¿ã¹ã‚‹å ´åˆ `x.len()` ã¨ã™ã‚Œã°ã‚µã‚¤ã‚ºãŒè¿”ã£ã¦ãã‚‹ã€‚  
è¦ç´ ã«æŒ‡å®šã™ã‚‹ã«ã¯Copyãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚  

#### å„è¦ç´ ã®ã‚¢ã‚¯ã‚»ã‚¹
**ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹**
é…åˆ—å¤–ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸå ´åˆpanicã«ãªã‚‹ã€‚  
getãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§å®‰å…¨ãªã‚¢ã‚¯ã‚»ã‚¹ãŒå¯èƒ½ã€‚  

```
let a1 = [1, 2, 3];

let a2: [f32; 3] = [1.1, 2.1, 3.1];
println!("{}", a1[0]);
println!("{}", a1.len());

println!("{}", a2[0]);

// 
let some = a1.get(0); // Optionå‹ã§è¿”ã‚‹
println!("{:?}", some);
let none = a1.get(5); // é…åˆ—å¤–ãªã‚‰Noneã«
println!("{:?}", none);
```

**ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿**
é…åˆ—ã®å…¨è¦ç´ ã«å¯¾ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã™ã‚‹å ´åˆã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã†ã€‚  
`å¤‰æ•°.iter()` ã§å–å¾—ã§ãã‚‹ã€‚ å€¤ã‚’å¤‰æ›´ã™ã‚‹å ´åˆ `å¤‰æ•°.iter_mut()` ã«ã™ã‚‹ã€‚  

```
let a1 = [1, 2, 3];
for i in a1.iter() {
    print!("{}", *i);
}

let mut a3 = [1, 2, 3];
for i in a3.iter_mut() {
    *i += 1;
}
```

len, iter, iter_mutãªã©ã¯é…åˆ—ã®æ©Ÿèƒ½ã§ã¯ãªãã€sliceå‹ã«æš—é»™çš„ãªå¤‰æ›ãŒè¡Œã‚ã‚Œå‘¼ã³å‡ºã•ã‚Œã‚‹ã€‚
ã“ã‚Œä»¥å¤–ã«ã‚‚sliceã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ã‚Šãã‚Œã‚‰ã‚‚åˆ©ç”¨å¯èƒ½ã€‚  

### ã‚¹ãƒ©ã‚¤ã‚¹
é…åˆ—è¦ç´ ã®ç¯„å›²ã«åŠ¹ç‡ã‚ˆãã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®ãƒ“ãƒ¥ãƒ¼ã¨ã—ã¦ä½¿ã†ã€‚  
é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªé ˜åŸŸã«åŒã˜å‹ã®è¦ç´ ãŒä¸¦ã‚“ã§ã„ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã‚ã‚Œã°ã©ã‚Œã§ã‚‚å¯¾è±¡ã«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
ä¸å¤‰å‚ç…§(&[å‹])ã€å¯å¤‰å‚ç…§(&mut [å‹])ã€Box(Box<å‹>)ã‚’çµŒç”±ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€‚  
é…åˆ—ã¨é•ã„å®Ÿä½“ã‚’æŒãŸãªã„ã®ã§ã€å‹ã«ã‚µã‚¤ã‚ºã¯ä¸è¦  
ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚¢ã‚¯ã‚»ã‚¹ä»¥å¤–ã«ã‚‚ `[begin..end]` ã®æŒ‡å®šãŒã§ãã‚‹ã€‚  
ã“ã®æ™‚endãŒå«ã¾ã‚Œãªã„ã“ã¨ã«æ³¨æ„  

```
let a1 = [1, 2, 3];
// let s1 = &a1; å‹ã‚’è¦‹ã‚‹æ„Ÿã˜ã“ã‚Œã ã¨é…åˆ—ã®å‚ç…§
let s1: &[i32] = &a1; // ã“ã‚Œã§sã¯ã‚¹ãƒ©ã‚¤ã‚¹ã«ãªã‚‹ã€‚

println!("{}", s1[0]);
println!("{:?}", a1.first()); // Some(1)ãŒè¿”ã‚‹
println!("{:?}", a1.last()); // Some(3)ãŒè¿”ã‚‹

let s2 = &a1[0..2];
let s3 = &a1[0..];
let s4 = &a1[..3];
println!("{:?}", s2); // [1, 2]
println!("{:?}", s3); // [2, 3]
println!("{:?}", s4); // [1, 2, 3]

// sort() ã¨ sort_ unstable() ã® é•ã„
// // sort() ã¯ å®‰å®š ã‚½ãƒ¼ãƒˆ ãªã®ã§ åŒ é † ãª ãƒ‡ãƒ¼ã‚¿ ã® ã‚½ãƒ¼ãƒˆ å‰ ã® é †åº ãŒ ã‚½ãƒ¼ãƒˆ å¾Œ ã‚‚ ä¿å­˜ ã• ã‚Œã‚‹
// // soft_ unstable() ã¯ å®‰å®š ã‚½ãƒ¼ãƒˆ ã§ã¯ ãªã„ ãŒã€ ä¸€èˆ¬çš„ ã« sort() ã‚ˆã‚Š é«˜é€Ÿ
//

let (s7, s8) = s6.split_at_mut(3);
println!("{:?}", s7); // [1, 3, 3]
println!("{:?}", s8); // [5, 5, 6, 8, 9, 9]
```

### str
Unicodeã®æ–‡å­—ã§æ§‹æˆã•ã‚ŒãŸæ–‡å­—åˆ—ã€‚  
strã¯ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¡Œã†ãŸã‚ã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹å‹ã¨ã‚‚å‘¼ã°ã‚Œã‚‹ã€‚  
å‹ã¯ `&str` ã«ãªã‚‹ã€‚
ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§ä½œã‚‹æ–‡å­—åˆ—ã¯strã«ãªã‚Šã€å‹ã¯ `&'static str` ã«ãªã‚‹ã€‚  

lenãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ãŸå ´åˆæ–‡å­—æ•°ã§ã¯ãªãã€ãƒã‚¤ãƒˆæ•°ãŒè¿”ã£ã¦ãã‚‹ã€‚
ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã®ã‚¢ã‚¯ã‚»ã‚¹ç­‰ã«é–¢ã—ã¦ã‚‚æ–‡å­—ã§ã¯ãªããƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã«ãªã‚‹ã€‚  

```
let str1 = "abcd";
println!("{}", str1);

let str2 = "abcd
efg"; // ã“ã®å ´åˆdã®å¾Œã«æ”¹è¡ŒãŒå…¥ã‚‹
println!("{}", str2);

let str3 = "abcd\
efg"; // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚’æŒ‡å®šã™ã‚Œã°æ”¹è¡Œã¯å…¥ã‚‰ãªã„
println!("{}", str3);

let str4 = r#"abc#d"\na"#; // r#""# ã§rawæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«ãªã‚‹
println!("{}", str4);

let str4 = r###"abcd"#\n"###; // r###""### ã¨ã™ã‚Œã° "# ãŒä½¿ãˆã‚‹
println!("{}", str4);

let str5 = "ã‚ã„ã†ãˆãŠ";
println!("{}", str5.len()); // 15ã«ãªã‚‹

let str6 = "ã‚,ã„\nã†ãˆãŠ";
let lines = str6.lines().next();

println!("{:?}", lines); // Some("ã‚ã„")

let mut chars = str6.chars(); // charå‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å–ã‚Šå‡ºã—
println!("{:?}", chars.next());

let mut chars_ind = str6.char_indices(); // char_indicesã‚’ä½¿ã†ã¨æ–‡å­—ã¨ä½ç½®ã®ã‚¿ãƒ—ãƒ«ã«ãªã‚‹
println!("{:?}", chars_ind.next()); // Some((0, 'ã‚'))
println!("{:?}", chars_ind.next()); // Some((3, ','))
```

## ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å‹

### Box<T>
Boxå‹ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ’ãƒ¼ãƒ—ã«ç§»å‹•ã—ã€ãã®å‚ç…§ã‚’ä¿æŒã™ã‚‹ã€‚  
Boxã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½œã‚‹ã¨ãã¯ `Box::new(å¤‰æ•°)` ã¨æ›¸ãã€‚  
ç§»å‹•ã•ã›ãŸå¤‰æ•°ã¯ç ´æ£„ã•ã‚Œã¦ã€ã‚¢ã‚¯ã‚»ã‚¹ã‚’ã—ãŸå ´åˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚  
ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤–ã‚ŒBoxå¤‰æ•°ãŒç ´æ£„ã•ã‚Œã‚‹æ™‚ã«ãƒ’ãƒ¼ãƒ—ã«ä½œã‚‰ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚‚ç ´æ£„ã•ã‚Œã‚‹ã€‚  

```
let t1 = (1, "aaa".to_string()); // (&str).to_string ã§ãƒ¡ãƒ¢ãƒªç¢ºä¿ã—ãŸæ–‡å­—åˆ—ã«ãªã‚‹
let b1 = Box::new(t1);

let (n1, s1) = &(*b1); // (*b1) ã§å®Ÿä½“ã‚’å–ã‚Šå‡ºã—ã¦ãã®å‚ç…§
println!("{}, {}", n1, s1);
println!("{:?}", b1);
```

### ãƒ™ã‚¯ã‚¿
å¯å¤‰é•·é…åˆ— é…åˆ—ã¯ã‚¹ã‚¿ãƒƒã‚¯ã«ç¢ºä¿ã™ã‚‹ãŒãƒ™ã‚¯ã‚¿ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ’ãƒ¼ãƒ—ã«ç¢ºä¿ã™ã‚‹ã€‚  
ãƒ‡ãƒ¼ã‚¿ã‚’ä½œã‚‹ã¨ãã¯ `vec![]` ã¨æ›¸ãã€‚  
`Vec::with_capacity(æ•°å€¤)` ã§ç¢ºä¿ã‚µã‚¤ã‚ºã®æŒ‡å®šãŒã§ãã‚‹ã€‚  

```
// ãƒ™ã‚¯ã‚¿
let mut v1 = vec![1, 2, 3, 4];
println!("legth {}, capacity {}", v1.len(), v1.capacity());
v1.push(5);
println!("legth {}, capacity {}", v1.len(), v1.capacity());
v1.pop();
println!("legth {}, capacity {}", v1.len(), v1.capacity());

v1.remove(0);
println!("legth {}, capacity {}", v1.len(), v1.capacity());
for i in v1.iter() {
    println!("{}", *i);
}

v1.insert(0, 5);
println!("legth {}, capacity {}", v1.len(), v1.capacity());
for i in v1.iter() {
    println!("{}", *i);
}

let mut v2 = vec![6, 7, 8];
v1.append(&mut v2); // appendã ã¨v2ã®ä¸­èº«ã‚’ç§»å‹•

let mut v2 = vec![6, 7, 8];
v1.extend_from_slice(&mut v2); // extend_from_sliceã ã¨v2ã®ä¸­èº«ã‚’ã‚³ãƒ”ãƒ¼

println!("v1: legth {}, capacity {}", v1.len(), v1.capacity());
for i in v1.iter() {
    println!("{}", *i);
}
println!("v2: legth {}, capacity {}", v2.len(), v2.capacity());

let mut empty: Vec<i32> = Vec::new(); // ç©ºã®é…åˆ—

let mut v3 = Vec::with_capacity(10); // ã‚µã‚¤ã‚ºã¯0ã§ã€ãƒ¡ãƒ¢ãƒªã¯10å€‹åˆ†ç¢ºä¿
println!("v3: legth {}, capacity {}", v3.len(), v3.capacity());
v3.insert(0, 1);
println!("v3: legth {}, capacity {}", v3.len(), v3.capacity());
for i in v3.iter() {
    println!("{}", *i);
}

// ã‚¹ãƒ©ã‚¤ã‚¹ã§å‚ç…§ã¯å¯èƒ½
let s1: &[i32] = &v2[0..];
println!("{}", s1[0]);

// Box<[i32]> ã«å¤‰æ›ã‚µã‚¤ã‚ºå¤‰æ›´ãŒã§ããªã„ãŸã‚å¿…è¦æœ€ä½é™ã«åˆ‡ã‚Šè©°ã‚ã‚‰ã‚Œã‚‹
let b1 = v2.into_boxed_slice();
println!("{}", b1[0]);

// Boxã‹ã‚‰Vecã«å¤‰æ›
let v2 = b1.into_vec();
println!("{:?}", v2);
```

### String
strå‹ã¨ä¼¼ãŸæ€§è³ªã‚’æŒã¤ãƒ’ãƒ¼ãƒ—é ˜åŸŸã«ãƒ¡ãƒ¢ãƒªç¢ºä¿ã‚’ã—ãŸæ–‡å­—åˆ—ã€‚  
strå‹ã¨é•ã„æ–‡å­—ã®è¿½åŠ ã‚„å‰Šé™¤ãªã©ã®æ“ä½œãŒå¯èƒ½ã€‚ã€€ã€€

```
let s1 = "abcd".to_string(); // std::string::Stringãªã‚‹
let mut s2 = format!("efghi");

println!("{}", type_of(&s2));
s2.push_str(&s1); // s2ã«s1ã®å†…å®¹ã‚’è¿½åŠ 
s2.push('ã‚'); // charå‹ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
println!("{}", s2);

println!("{}", s2.len());

// strå‹ã¨åŒã˜ãcharå‹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚¿ãƒ—ãƒ«ã‚’è¿”ã™
for i in s2.char_indices() {
    println!("{:?}", i);
}

let format_string = format!("{}", 1);
println!("{}", format_string);

let parse_test = "1".parse::<i32>(); // æ–‡å­—åˆ—ã‹ã‚‰æ•°å€¤ã¸ã®å¤‰æ›
if let Ok(v) = parse_test {
    println!("{}", v);
}
```

æ–‡å­—åˆ—ã¯ã“ã‚Œä»¥å¤–ã«ã‚‚
- CString, CStr  
Cè¨€èªã§ä½¿ã‚ã‚Œã‚‹ãƒŒãƒ«çµ‚ç«¯æ–‡å­—åˆ—  
- OsString, OsStr  
OSã®ãƒã‚¤ãƒ†ã‚£ãƒ–æ–‡å­—åˆ—
- PathBuf, Path
ãƒ‘ã‚¹æ–‡å­—åˆ— OSé–“ã®ãƒ‘ã‚¹åŒºåˆ‡ã‚Šã®å·®ç•°å¸åã‚’ã—ã¦ãã‚Œã‚‹


### Range
ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œã‚‹æ™‚ã«åˆ©ç”¨ã—ãŸæ§‹æ–‡ã¯ç¯„å›²ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã€‚  
`start..end`, `..end`, `start..`, `start..=end`  
ã¨å¤šæ•°ã®æŒ‡å®šãŒã‚ã‚‹ã€‚  

Rangeã‚’ä½¿ã†ã“ã¨ã§ç‰¹å®šå›æ•°ãƒ«ãƒ¼ãƒ—ã‚’ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚‚ç°¡å˜ã«æ›¸ã‘ã‚‹

```
for i in 0..12 {
    println!("{}", i);
}
```


### ã‚ªãƒ—ã‚·ãƒ§ãƒ³å‹
å€¤ãŒã‚ã‚‹ã®ã‹ä¸æ˜ãªæˆ»ã‚Šå€¤ã«ä½¿ã‚ã‚Œã‚‹ã€‚  
Cè¨€èªãªã©ã¯nullã§è¡¨ç¾ã—ã¦ã„ã‚‹ãŒrustã§ã¯Optionå‹ã‚’åˆ©ç”¨ã™ã‚‹ã€‚  
å€¤ãŒã‚ã‚‹å ´åˆã¯Someã¨ãªã‚Šã€ãªã„å ´åˆã¯Noneã«ãªã‚‹ã€‚  

```
let a1 = [1, 2, 3, 4];
let op1 = a1.get(0);

// å®‰å…¨ãªå€¤ã®å–ã‚Šå‡ºã—
if let Some(value) = op1 {
    println!("{}", value);
}

// unwrapã§å€¤ã®å–å‡ºã—
// Noneã«å¯¾ã—ã¦è¡Œã†ã¨panic
let value2 = op1.unwrap();
println!("{}", value2);

let op2 = None;
let value3 = op2.unwrap_or_else(|| 0); // Noneã®æ™‚ã«ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å®Ÿè¡Œ
println!("{}", value3);


fn option() -> Option<i32> {
    let a1 = [1, 2, 3, 4];
    let op1 = a1.get(4)?; // ?ã§å€¤ã‚’å–ã‚Šå‡ºã™ã€Noneã®å ´åˆã¯ã“ã®é–¢æ•°ã®æˆ»ã‚Šåœ°ã‚‚Noneã«ãªã‚‹
    let op2 = a1.get(1)?;

    Some(op1 + op2)
}
```

### ãƒªã‚¶ãƒ«ãƒˆå‹
å‘¼ã³å‡ºã—ã®çµæœã‚¨ãƒ©ãƒ¼ã«ãªã‚‹å¯èƒ½æ€§ã‚’æš—ç¤ºã™ã‚‹å‹  
Okã¨Errã®ï¼’ã¤ã®å€¤ãŒã‚ã‚‹ã€‚  
ã‚ªãƒ—ã‚·ãƒ§ãƒ³å‹ã¨ã®é•ã„ã¯Errã§ã¯å¤±æ•—ã—ãŸç†ç”±ã®æƒ…å ±ã‚’æŒã¦ã‚‹ã€‚  

ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ä½¿ã£ãŸæ©Ÿèƒ½ã¯ãƒªã‚¶ãƒ«ãƒˆã§ã‚‚åŒã˜ã‚ˆã†ã«ä½¿ãˆã‚‹ã€‚
```
let parse_ok = "1".parse::<i32>(); // æ–‡å­—åˆ—ã‹ã‚‰æ•°å€¤ã¸ã®å¤‰æ›
println!("{:?}", parse_ok);

let parse_err = "a".parse::<i32>(); // æ–‡å­—åˆ—ã‹ã‚‰æ•°å€¤ã¸ã®å¤‰æ›
println!("{:?}", parse_err); // Err(ParseIntError { kind: InvalidDigit })ã«ãªã‚‹
```

## æ–°ã—ã„å‹ã®å®šç¾©

### ã‚¨ã‚¤ãƒªã‚¢ã‚¹
å‹ã«åˆ¥åã‚’ã¤ã‘ã¦åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹  
`type ã‚¨ã‚¤ãƒªã‚¢ã‚¹ = å‹` ã§è¨˜è¿°ã™ã‚‹ã€‚  


### æ§‹é€ ä½“
3ç¨®é¡ã®æ§‹é€ ä½“ãŒå­˜åœ¨ã—ã¦ã„ã¦ã€ãã‚Œãã‚Œ 
- åå‰ä»˜ããƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ§‹é€ ä½“
- ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“
- ãƒ¦ãƒ‹ãƒƒãƒˆæ§‹é€ ä½“

ã®3ã¤ãŒã‚ã‚‹ã€‚

#### åå‰ä»˜ããƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ§‹é€ ä½“
ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆã« `#[derive(Debug)]` ã‚’è¿½åŠ ã™ã‚‹ã¨  
formatã‚„printã§è‡ªå‹•å‡ºåŠ›ãŒã§ãã‚‹ã®ã§ä¾¿åˆ©  

```
struct å‹å {
    å¤‰æ•°å: å‹,
}
```
ã§å®šç¾©ã™ã‚‹ã€‚  

```
#[derive(Debug)]
struct Human {
    age: i32,
    name: std::string::String,
}

let human = Human {
    age: 20,
    name: format!("human"),
};

println!("{}", human.age);
println!("{}", human.name);

// ã“ã‚“ãªåˆæœŸåŒ–ã‚‚ã§ãã‚‹
// çœç•¥å½¢ã®åˆæœŸåŒ–ã®å ´åˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ä¸€è‡´ã™ã‚‹å¤‰æ•°ã‚’ä¸ãˆã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
let age = 20;
let name = format!("human_init1");
let human_init1 = Human { name, age };

// ã“ã®åˆæœŸåŒ–ã¯ageã¯ç›´æ¥ã—ã¦ã„ã—ã¦ã€nameã¯human_init1ã‚’åˆ©ç”¨ã™ã‚‹
// ãŸã ã€Stringãªã©ãƒ ãƒ¼ãƒ–ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„ã®ã§æ³¨æ„
let human_init2 = Human {
    name: format!("human_init2"),
    ..human_init1
};

println!("{:?}", human_init1);
println!("{:?}", human_init2);

// Defaultã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆã‚’æŒ‡å®šã™ã‚‹ã¨
// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ä½¿ãˆã‚‹
#[derive(Default, Debug)]
struct DefaultStruct {
    param1: i32,
    param2: i32,
}

let default_struct1: DefaultStruct = Default::default();
println!("{:?}", default_struct1);

let default_struct2 = DefaultStruct {
    param1: 20,
    ..Default::default()
};
println!("{:?}", default_struct2);

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒ‡å®šã—ãŸã„å ´åˆ
// Defaultãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹
#[derive(Debug)]
struct DefaultStructTrait {
    param1: i32,
    param2: i32,
}

impl Default for DefaultStructTrait {
    fn default() -> Self {
        Self {
            param1: 1,
            param2: 2,
        }
    }
}

let default_struct_trait: DefaultStructTrait = Default::default();
println!("{:?}", default_struct_trait);
```


#### ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“
åå‰ã®é€šã‚Šã‚¿ãƒ—ãƒ«æ§‹é€ ä½“  
ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åå‰ã‚’ä¸ãˆã¦ãªã„ã®ã§å¤‰æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ã‚¿ãƒ—ãƒ«ã¨åŒã˜ã‚ˆã†ã« `.0`ã®å½¢ã«ãªã‚‹ã€‚

ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“ã®ä¾¿åˆ©ãªä½¿ã„æ–¹ã¨ã—ã¦ã€newtypeã¨ã„ã†ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã‚ã‚‹ã€‚  
ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã ã¨å…ƒã®å‹ã®åˆ¥åã¨ã—ã¦æ‰±ã†ã ã‘ãªã®ã§ã€å…ƒã®å‹ã®å¤‰æ•°ã‚’ä»£å…¥ã™ã‚‹ãªã©ãŒå¯èƒ½ã«ãªã£ã¦ã„ã‚‹ã€‚  
ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“ã‚’åˆ©ç”¨ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®å‹ãƒã‚§ãƒƒã‚¯ã‚’å¼·åŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```
#[derive(Debug)]
struct TupleStruct(i32, i32);

let tuple_struct = TupleStruct(1, 2);
println!("{}", tuple_struct.0);
println!("{}", tuple_struct.1);

// newtypeã§å‹ãƒã‚§ãƒƒã‚¯ã‚’å¼·åŒ–
type Int32 = i32;

#[derive(Debug)]
struct Struct1 {
    param1: Int32,
    param2: Int32,
}

let param1 = 1;
let param2 = 2;

// Struct1ã®åˆæœŸåŒ–ã§i32ã®å¤‰æ•°ã‚’ä½¿ã£ã¦ã‚‚OK
println!("{:?}", Struct1 { param1, param2 });

#[derive(Debug)]
struct NewType(i32);

#[derive(Debug)]
struct Struct2 {
    param1: Int32,
    param2: NewType,
}

// ã“ã‚Œã¯ã‚¨ãƒ©ãƒ¼
// println!("{:?}", Struct2 { param1, param2 });
println!(
    "{:?}",
    Struct2 {
        param1,
        param2: NewType(2)
    }
);
```


#### ãƒ¦ãƒ‹ãƒƒãƒˆæ§‹é€ ä½“
å€¤ã‚’æŒãŸãªã„æ§‹é€ ä½“  
ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒãŸãªã„ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã‚’ã—ãŸã„æ™‚ã«ä½¿ã†  

```
struct UnitStruct;
println!("{}", std::mem::size_of::<UnitStruct>()); // ã‚µã‚¤ã‚ºã¯0ãƒã‚¤ãƒˆ
```


### åˆ—æŒ™å‹
rustã®enumã¯å®šæ•°ã ã‘ã§ã¯ãªãã€å„å®šç¾©å›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚‚ãŸã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
Optionã‚‚åˆ—æŒ™å‹ã§å®šç¾©ã•ã‚Œã¦ã„ã¦ã€Someã¯å€¤ã‚’æŒã¡Noneã¯å€¤ã‚’æŒãŸãªæ§˜ãªå·®ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
ãƒ‡ãƒ¼ã‚¿ã®æŒãŸãªã„åˆ—æŒ™å‹ã¯isizeå‹ã®æ•´æ•°å€¤ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã€‚  

#### å®šæ•°ã®ã¿

```
// PartialEqã‚’ä»˜ã‘ã‚‹ã¨ == ã§ã®æ¯”è¼ƒãŒå¯èƒ½
#[derive(Debug, PartialEq)]
enum Enum {
    Zero,
    One,
    Two,
}

let enum_value = Enum::Zero;

match enum_value {
    Enum::Zero => println!("zero"),
    Enum::One => println!("one"),
    Enum::Two => println!("two"),
}

if enum_value == Enum::Zero {}

println!("{}", type_of(Enum::Zero));

enum EnumValueSet {
    Zero = 1,
    One = 2,
    Two = 3,
}
```

#### ãƒ‡ãƒ¼ã‚¿ã‚’æŒã¤åˆ—æŒ™å‹
åˆ—æŒ™å‹ã¯æ•´æ•°å€¤ä»¥å¤–ã«ã‚‚æ§‹é€ ä½“ã¨åŒã˜æ§‹æ–‡ã§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚‚ãŸã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚  
ãƒ‡ãƒ¼ã‚¿ã‚’æŒã¤Enumã¯matchå¼ã‚’åˆ©ç”¨ã—ã¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤ã‚’åˆ¥å¤‰æ•°ã«æŸç¸›ã§ãã‚‹ã€‚  

```
#[derive(Debug, PartialEq)]
enum Enum {
    Zero,
    One { param1: i32, param2: i32 },
    Two,
}

let data = [
    Enum::Zero,
    Enum::One {
        param1: 0,
        param2: 1,
    },
    Enum::Two,
];

for i in data.iter() {
    match i {
        Enum::One { param1, param2 } => println!("param1:{}, param2:{}", param1, param2),
        _ => println!("{:?}", i),
    }
}
```

## å‹å¤‰æ›

### å‹ã‚­ãƒ£ã‚¹ãƒˆ
asã‚’åˆ©ç”¨ã—ã¦è¡Œã†æ˜ç¤ºçš„ãªå‹å¤‰æ›ã€‚  
æ¡ã‚ãµã‚Œã®ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã‚ãªã„ã€‚  
as ã¯ã‚¹ã‚«ãƒ©å‹ã®ã¿ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¦ã€ã‚¿ãƒ—ãƒ«ã‚„æ§‹é€ ä½“ã«å¯¾ã—ã¦è¡Œã†ã“ã¨ã¯ã§ããªã„ã€‚(Formãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã¨å¯èƒ½) 

```
let c1 = 'a';
let us1 = c1 as i8;

println!("{}", us1); // aã®æ–‡å­—ã‚³ãƒ¼ãƒ‰

let n1 = 300;
let us2 = n1 as i8;
println!("{}", us2); // æ¡ã‚ãµã‚Œã¯ã—ãªã„ã§44ã«ãªã‚‹ 300 % 256
```

### Transmute
std::mem::transmuteã¯æ˜ç¤ºçš„ãªå‹å¤‰æ›ã€‚  
ãƒ“ãƒƒãƒˆåˆ—ã®ã‚µã‚¤ã‚ºãŒåŒã˜ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦è¡Œã†ã“ã¨ãŒã§ãã‚‹ã€‚  
asã¨é•ã„å‹ã®æƒ…å ±ã®ã¿ã‚’å¤‰æ›ã—ã¦ã€ãƒ“ãƒƒãƒˆåˆ—ã¯åŒã˜çŠ¶æ…‹ã«ãªã‚‹ã®ã§ f -> i32 ã¿ãŸã„ãªå¤‰æ›ã‚’ã™ã‚‹ã¨ã§ã‹ã„å€¤ã«ãªã£ãŸã‚Šã™ã‚‹ã€‚  

```
let c1 = 'a';
//     let us1: i8 = unsafe { std::mem::transmute(c1) }; // ãƒã‚¤ãƒˆã‚µã‚¤ã‚ºãŒé•ã†ã®ã§ã‚¨ãƒ©ãƒ¼
let n1: i32 = unsafe { std::mem::transmute(c1) }; // ã“ã£ã¡ã¯å¯èƒ½

println!("{}", n1);
```

## æ§‹æ–‡
### useå®£è¨€
ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹è¦ç´ ã‚’çŸ­ãæ›¸ã‘ã‚‹ã€‚  
ä¾‹ãˆã°å‹åã‚’å–å¾—ã™ã‚‹ `std::any::type_name` ã‚’useå®£è¨€ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ `any::type_name` ã¨æ›¸ã‘ã‚‹ã€‚

```
use std::any;

fn type_of<T>(_: T) -> String {
    let a = any::type_name::<T>();
    return a.to_string();
}
```

### é–¢æ•°

```
fn é–¢æ•°å(å¼•æ•°: å‹) -> æˆ»ã‚Šå€¤ã®å‹ {
}
```
æˆ»ã‚Šå€¤ã‚’æ›¸ã‹ãªã„å ´åˆã¯å¼·åˆ¶çš„ã«unitå‹ã«ãªã‚‹


### ãƒ¡ã‚½ãƒƒãƒ‰
æ§‹é€ ä½“ã«å®šç¾©ã•ã‚ŒãŸé–¢æ•°  
ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã€‚
`impl å‹` ã®ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§é–¢æ•°ã‚’å®šç¾©ã™ã‚‹ã€‚  
ãƒ¡ã‚½ãƒƒãƒ‰ã®å ´åˆå¿…ãšå¼•æ•°ã« `self` ãŒå¿…è¦ã§ã“ã‚ŒãŒã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ãªã‚‹ã€‚  

```
#[derive(Debug)]
struct Vector2 {
    x: f32,
    y: f32,
}

impl Vector2 {
    fn length(&self) -> f32 {
        (self.x * self.x + self.y * self.y).sqrt()
    }

    fn add_x(&mut self, value: f32) {
        self.x += value;
    }
}
```

### é–¢é€£é–¢æ•°
ã“ã‚Œã‚‚æ§‹é€ ä½“ã«å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã ãŒã€ãƒ¡ã‚½ãƒƒãƒ‰ã¨é•ã„å‹ã«ç´ä»˜ã‘ã•ã‚Œã¦ã„ã‚‹ã€‚  
å®šç¾©ã‚‚ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ã ãŒã€`self` ã‚’å¼•æ•°ã«å–ã‚‰ãªãã™ã‚‹ã“ã¨ã§é–¢é€£é–¢æ•°ã«ãªã‚‹ã€‚

```
#[derive(Debug)]
struct Vector2 {
    x: f32,
    y: f32,
}

impl Vector2 {
    fn length(&self) -> f32 {
        (self.x * self.x + self.y * self.y).sqrt()
    }

    fn add_x(&mut self, value: f32) {
        self.x += value;
    }

    fn new() -> Vector2 {
        Vector2 { x: 0.0, y: 0.0 }
    }
}
```

### åˆ†å²
**ifå¼**

```
if a == 0 {
    println!("{} is zero", a);
} else if a % 2 == 0 {
    println!("{} is even", a);
} else {
    println!("{} is odd", a);
}
```

rustã§ã®ifã¯å¼ãªã®ã§å€¤ã‚’è¿”ã™ã“ã¨ã‚‚ã§ãã‚‹ã€‚

```
let a = 12;

let result = if a == 0 { "even" } else { "odd" };
println!("{} is {}", a, result);
```

**if letå¼**
ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’1ã¤ã ã‘æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚  
ä¸»ã«Resultå‹ã‚„Optionå‹ãªã©ã§ä½¿ã†ã€‚

```
let mut s = String::new();
io::stdin().read_line(&mut s).ok();

// parseã®æˆ»ã‚Šå€¤ãŒOkãªã‚‰ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§çµæœå€¤ãŒåˆ©ç”¨ã§ãã‚‹
if let Ok(s_r) = s.trim().parse::<i32>() {
    let type_str = type_of(s_r);
    println!("{}: {}", s_r, type_str);
    a = s_r;
}
```



**matchå¼**
```
let mut a = 12;

let mut s = String::new();
io::stdin().read_line(&mut s).ok();

if let Ok(s_r) = s.trim().parse::<i32>() {
    let type_str = type_of(s_r);
    println!("{}: {}", s_r, type_str);
    a = s_r;
}

match a {
    1 => println!("one"),
    10 => println!("ten"),
    _ => println!("some"),
};
```

matchã‚‚ifåŒæ§˜ã«å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ãã‚‹ã€‚

```
let m_result = match a {
    1 => "a",
    10 => "b",
    _ => "z",
};
```

matchå¼ã§ã¯ã©ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚‚ãƒãƒƒãƒã—ãªã„ã‚ˆã†ãªçµæœãŒã‚ã‚‹ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚  
ã©ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚‚ãƒãƒƒãƒã—ãªã„å ´åˆ `_` ã‚’ä½¿ã£ã¦å‡¦ç†ã‚’è¡Œã†ã€‚  

### ç¹°ã‚Šè¿”ã—

**loopå¼**  
çµ‚äº†æ¡ä»¶ã®ãªã„ç„¡é™ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦å‹•ä½œã™ã‚‹ã€‚  
loopã‹ã‚‰æŠœã‘ã‚‹å ´åˆ `break` ã‚’ä½¿ã†ã€‚  
loopå¼ã‹ã‚‰å€¤ã‚’è¿”ã™å ´åˆbreakã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¾Œã«å€¤ã‚’è¨˜è¿°ã™ã‚‹ã€‚

```
loop {
    break 1;
}
```

**whileå¼**  
æ¡ä»¶ä»˜ãã®ãƒ«ãƒ¼ãƒ—ã€‚  
loopå¼ã¨é•ã„å€¤ã‚’è¿”ã™ã“ã¨ãŒã§ããªã„ã€‚  
è¿”ã™å€¤ã¯å¸¸ã«()ã¨ãªã‚‹ã€‚  

```
while true {

}
```

**while letå¼**  
ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’è¡Œã„æˆåŠŸã—ãŸæ™‚ã«ãƒ«ãƒ¼ãƒ—æœ¬ä½“ã‚’å®Ÿè¡Œã™ã‚‹ã€‚

```
let value = Some(10);
while let Some(v) = value {
    println!("{}", v);
}
```

**forå¼**  
ãƒ™ã‚¯ã‚¿ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãªã©ã«ç¹°ã‚Šè¿”ã—ãŒã§ãã‚‹ã€‚  

```
let vector = vec!["one", "two", "three"];
for v in vector.iter() {
    println!("{}", v);
}
```

### ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£
Rustã«ãŠã‘ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ç„¡åé–¢æ•°ã«ãªã‚‹ã€‚  

```
let f = |å¼•æ•°ãƒªã‚¹ãƒˆ| {
    // å‡¦ç†
};
```
ã“ã‚ŒãŒç„¡åé–¢æ•°ã®å®šç¾©ã«ãªã‚‹ã€‚

```
let mut base = 1;
let add = |value| value + base;
println!("{}", add(10));

// base = 5; // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
println!("{}", add(10));
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹åŸå› ã¯ base ã‚’ç„¡åé–¢æ•°ã«æ¸¡ã—ã¦ã„ã‚‹ãŸã‚ã€‚  
ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«baseå¤‰æ•°ã‚’è²¸ã—ã¦ã„ã‚‹çŠ¶æ…‹ãªã®ã§ã€baseã‚’ä½¿ãŠã†ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚  
è²¸ã™ã®ã§ã¯ãªãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã„å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚Œã°å›é¿ãŒã§ãã‚‹ã€‚  
moveã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã†ã¨æ‰€æœ‰æ¨©ãŒã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã«ç§»ã‚‹ã€‚ãŸã ã€Copyãƒˆãƒ¬ã‚¤ãƒˆã‚’æŒã¤å‹ã¯ã‚³ãƒ”ãƒ¼ã‚’ã—ã¦ãã‚Œã‚‹ã€‚

```
let mut base = 1;
let add = move |value| value + base;
println!("{}", add(10));

base = 5;
println!("{}", add(10));
```

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
`mod`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã†ã“ã¨ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã”ã¨ã«åˆ†å‰²ãŒã§ãã€å¤–éƒ¨ã«å…¬é–‹ãƒ»éå…¬é–‹ãŒã§ãã‚‹ã€‚  

```
mod math {
    #[derive(Debug)]
    pub struct Vector {
        pub x: f32,
        pub y: f32,
    }

    impl Vector {
        pub fn length(&self) -> f32 {
            (self.x * self.x + self.y * self.y).sqrt()
        }
    }
}

fn main() {
    let v = math::Vector { x: 5.0, y: 5.0 };
    println!("{:?} {}", v, v.length());
}
```

`mod`ã®ä¸­ã§`pub`ã¨ã¤ã‘ã‚‹ã¨å…¬é–‹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ãªã‚Šã€ãã‚Œä»¥å¤–ã¯éå…¬é–‹ã«ãªã‚‹ã€‚  
structã®ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚’éå…¬é–‹ã«ã™ã‚‹ã¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åæŒ‡å®šã§ã®åˆæœŸåŒ–ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã€‚  
ã¾ãŸã€`pub`ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯`pub(å…¬é–‹å…ˆ)`ã¨ã™ã‚‹ã“ã¨ã§ä¸€éƒ¨ã®å ´æ‰€ã«å¯¾ã—ã¦ã ã‘å…¬é–‹ã«ã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹ã€‚  

```
mod hoge {
    pub(crate) fn echo() {
        println!("hoge.echo");
        self::fuga::echo();
        self::fuga::piyo::t();
    }

    mod fuga {
        pub(super) fn echo() {
            println!("hoge.fuga.echo");
        }

        pub(super) mod piyo {
            pub(in crate::hoge) fn t() {
                super::echo();
                println!("hoge.fuga.piyo.echo");
            }
        }
    }
}

fn main() {
    crate::hoge::echo();
}
```

- crate  
ãƒ«ãƒ¼ãƒˆã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡ã™ç‰¹åˆ¥ãªåå‰  
`pub(crate)`ã¨ã™ã‚‹ã¨`crate::`ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã€‚
- super  
è¦ªã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡ã™  
- self
ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒ‡ã™  
- in ~~
ç›¸å¯¾ãƒ‘ã‚¹ã§æŒ‡å®šã—ã¦å…¬é–‹å…ˆã®æŒ‡æ‘˜ãŒã§ãã‚‹ã€‚  
ã‚ã¾ã‚Šä½¿ã‚ãªãã†ãªæ°—ã‚‚ã™ã‚‹ã€‚  

### ãƒ•ã‚¡ã‚¤ãƒ«åˆ†å‰²
ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ‡ã‚Šå‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚  
src/new.rs ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã¤ãã‚‹ã¨`new`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦æ‰±ã†ã€‚  
ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½¿ã†ã“ã¨ã§éšå±¤ã‚’è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

**åŒéšå±¤**
```
// src/new.rs
pub fn test() {
    println!("new.test");
}

// src/main.rs
mod new;

fn main() {
    new::test();
}
```
main.rsã¨åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚½ãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆ `mod ãƒ•ã‚¡ã‚¤ãƒ«å` ã§ä½¿ã†ã“ã¨ãŒã§ãã‚‹ã€‚  

**å­éšå±¤**
ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚½ãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆã¯ã¡ã‚‡ã£ã¨æ‰‹é–“ãŒã‹ã‹ã‚‹ã€‚  
ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã¨åŒã˜åå‰ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚Šã€ãã“ã«ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å…¬é–‹è¨­å®šã‚’è¡Œã†ã²ã¤ã‚ˆã†ãŒã‚ã‚‹ã€‚  

```
// src/nest/nestfile.rs
pub fn test() {
    println!("nest.test");
}

// src/nest.rs
pub mod nestfile;

// src/main.rs
mod nest;

fn main() {
    nest::nestfile::test();
}
```

ã¾ãŸã€`use`ã‚’ä½¿ã†ã“ã¨ã§çœç•¥ã§ãã‚‹ã€‚  
```
mod nest;
use nest::nestfile;
fn main() {
    nestfile::test();
}
```